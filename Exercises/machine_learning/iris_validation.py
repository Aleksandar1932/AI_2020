import warnings
from sklearn.exceptions import ConvergenceWarning
from sklearn.neural_network import MLPClassifier

DATASET = [
	[6.3, 2.9, 5.6, 1.8, 0],
	[6.5, 3.0, 5.8, 2.2, 0],
	[7.6, 3.0, 6.6, 2.1, 0],
	[4.9, 2.5, 4.5, 1.7, 0],
	[7.3, 2.9, 6.3, 1.8, 0],
	[6.7, 2.5, 5.8, 1.8, 0],
	[7.2, 3.6, 6.1, 2.5, 0],
	[6.5, 3.2, 5.1, 2.0, 0],
	[6.4, 2.7, 5.3, 1.9, 0],
	[6.8, 3.0, 5.5, 2.1, 0],
	[5.7, 2.5, 5.0, 2.0, 0],
	[5.8, 2.8, 5.1, 2.4, 0],
	[6.4, 3.2, 5.3, 2.3, 0],
	[6.5, 3.0, 5.5, 1.8, 0],
	[7.7, 3.8, 6.7, 2.2, 0],
	[7.7, 2.6, 6.9, 2.3, 0],
	[6.0, 2.2, 5.0, 1.5, 0],
	[6.9, 3.2, 5.7, 2.3, 0],
	[5.6, 2.8, 4.9, 2.0, 0],
	[7.7, 2.8, 6.7, 2.0, 0],
	[6.3, 2.7, 4.9, 1.8, 0],
	[6.7, 3.3, 5.7, 2.1, 0],
	[7.2, 3.2, 6.0, 1.8, 0],
	[6.2, 2.8, 4.8, 1.8, 0],
	[6.1, 3.0, 4.9, 1.8, 0],
	[6.4, 2.8, 5.6, 2.1, 0],
	[7.2, 3.0, 5.8, 1.6, 0],
	[7.4, 2.8, 6.1, 1.9, 0],
	[7.9, 3.8, 6.4, 2.0, 0],
	[6.4, 2.8, 5.6, 2.2, 0],
	[6.3, 2.8, 5.1, 1.5, 0],
	[6.1, 2.6, 5.6, 1.4, 0],
	[7.7, 3.0, 6.1, 2.3, 0],
	[6.3, 3.4, 5.6, 2.4, 0],
	[5.1, 3.5, 1.4, 0.2, 1],
	[4.9, 3.0, 1.4, 0.2, 1],
	[4.7, 3.2, 1.3, 0.2, 1],
	[4.6, 3.1, 1.5, 0.2, 1],
	[5.0, 3.6, 1.4, 0.2, 1],
	[5.4, 3.9, 1.7, 0.4, 1],
	[4.6, 3.4, 1.4, 0.3, 1],
	[5.0, 3.4, 1.5, 0.2, 1],
	[4.4, 2.9, 1.4, 0.2, 1],
	[4.9, 3.1, 1.5, 0.1, 1],
	[5.4, 3.7, 1.5, 0.2, 1],
	[4.8, 3.4, 1.6, 0.2, 1],
	[4.8, 3.0, 1.4, 0.1, 1],
	[4.3, 3.0, 1.1, 0.1, 1],
	[5.8, 4.0, 1.2, 0.2, 1],
	[5.7, 4.4, 1.5, 0.4, 1],
	[5.4, 3.9, 1.3, 0.4, 1],
	[5.1, 3.5, 1.4, 0.3, 1],
	[5.7, 3.8, 1.7, 0.3, 1],
	[5.1, 3.8, 1.5, 0.3, 1],
	[5.4, 3.4, 1.7, 0.2, 1],
	[5.1, 3.7, 1.5, 0.4, 1],
	[4.6, 3.6, 1.0, 0.2, 1],
	[5.1, 3.3, 1.7, 0.5, 1],
	[4.8, 3.4, 1.9, 0.2, 1],
	[5.0, 3.0, 1.6, 0.2, 1],
	[5.0, 3.4, 1.6, 0.4, 1],
	[5.2, 3.5, 1.5, 0.2, 1],
	[5.2, 3.4, 1.4, 0.2, 1],
	[5.5, 2.3, 4.0, 1.3, 2],
	[6.5, 2.8, 4.6, 1.5, 2],
	[5.7, 2.8, 4.5, 1.3, 2],
	[6.3, 3.3, 4.7, 1.6, 2],
	[4.9, 2.4, 3.3, 1.0, 2],
	[6.6, 2.9, 4.6, 1.3, 2],
	[5.2, 2.7, 3.9, 1.4, 2],
	[5.0, 2.0, 3.5, 1.0, 2],
	[5.9, 3.0, 4.2, 1.5, 2],
	[6.0, 2.2, 4.0, 1.0, 2],
	[6.1, 2.9, 4.7, 1.4, 2],
	[5.6, 2.9, 3.6, 1.3, 2],
	[6.7, 3.1, 4.4, 1.4, 2],
	[5.6, 3.0, 4.5, 1.5, 2],
	[5.8, 2.7, 4.1, 1.0, 2],
	[6.2, 2.2, 4.5, 1.5, 2],
	[5.6, 2.5, 3.9, 1.1, 2],
	[5.9, 3.2, 4.8, 1.8, 2],
	[6.1, 2.8, 4.0, 1.3, 2],
	[6.3, 2.5, 4.9, 1.5, 2],
	[6.1, 2.8, 4.7, 1.2, 2],
	[6.4, 2.9, 4.3, 1.3, 2],
	[6.6, 3.0, 4.4, 1.4, 2],
	[6.8, 2.8, 4.8, 1.4, 2],
	[6.7, 3.0, 5.0, 1.7, 2],
	[6.0, 2.9, 4.5, 1.5, 2],
	[5.7, 2.6, 3.5, 1.0, 2],
	[5.5, 2.4, 3.8, 1.1, 2],
	[5.4, 3.0, 4.5, 1.5, 2],
	[6.0, 3.4, 4.5, 1.6, 2],
	[6.7, 3.1, 4.7, 1.5, 2],
	[6.3, 2.3, 4.4, 1.3, 2],
	[5.6, 3.0, 4.1, 1.3, 2],
	[5.5, 2.5, 4.0, 1.3, 2],
	[5.5, 2.6, 4.4, 1.2, 2],
	[6.1, 3.0, 4.6, 1.4, 2],
	[5.8, 2.6, 4.0, 1.2, 2],
	[5.0, 2.3, 3.3, 1.0, 2],
	[5.6, 2.7, 4.2, 1.3, 2],
	[5.7, 3.0, 4.2, 1.2, 2],
	[5.7, 2.9, 4.2, 1.3, 2],
	[6.2, 2.9, 4.3, 1.3, 2],
	[5.1, 2.5, 3.0, 1.1, 2],
	[5.7, 2.8, 4.1, 1.3, 2],
	[6.4, 3.1, 5.5, 1.8, 0],
	[6.0, 3.0, 4.8, 1.8, 0],
	[6.9, 3.1, 5.4, 2.1, 0],
	[6.8, 3.2, 5.9, 2.3, 0],
	[6.7, 3.3, 5.7, 2.5, 0],
	[6.7, 3.0, 5.2, 2.3, 0],
	[6.3, 2.5, 5.0, 1.9, 0],
	[6.5, 3.0, 5.2, 2.0, 0],
	[6.2, 3.4, 5.4, 2.3, 0],
	[4.7, 3.2, 1.6, 0.2, 1],
	[4.8, 3.1, 1.6, 0.2, 1],
	[5.4, 3.4, 1.5, 0.4, 1],
	[5.2, 4.1, 1.5, 0.1, 1],
	[5.5, 4.2, 1.4, 0.2, 1],
	[4.9, 3.1, 1.5, 0.2, 1],
	[5.0, 3.2, 1.2, 0.2, 1],
	[5.5, 3.5, 1.3, 0.2, 1],
	[4.9, 3.6, 1.4, 0.1, 1],
	[4.4, 3.0, 1.3, 0.2, 1],
	[5.1, 3.4, 1.5, 0.2, 1],
	[5.0, 3.5, 1.3, 0.3, 1],
	[4.5, 2.3, 1.3, 0.3, 1],
	[4.4, 3.2, 1.3, 0.2, 1],
	[5.0, 3.5, 1.6, 0.6, 1],
	[5.9, 3.0, 5.1, 1.8, 0],
	[5.1, 3.8, 1.9, 0.4, 1],
	[4.8, 3.0, 1.4, 0.3, 1],
	[5.1, 3.8, 1.6, 0.2, 1],
	[5.5, 2.4, 3.7, 1.0, 2],
	[5.8, 2.7, 3.9, 1.2, 2],
	[6.0, 2.7, 5.1, 1.6, 2],
	[6.7, 3.1, 5.6, 2.4, 0],
	[6.9, 3.1, 5.1, 2.3, 0],
	[5.8, 2.7, 5.1, 1.9, 0],
]


def split_dataset(dataset):
	# Split the dataset into training set (first 90%) and validation set (last 10%)
	# return dataset[:int(len(dataset) * 0.9)], dataset[int(len(dataset) * 0.9):]
	return dataset[:-10], dataset[-10:]


def divide_set(set_to_div):
	# Split the particular subset (of the dataset) to X and Y (features and labels)
	return [row[0:-1] for row in set_to_div], [row[-1] for row in set_to_div]


def calculate_accuracy(predicted_classes, exact_classes):
	# Calculate the number of correct predictions
	correct_cases = 0
	for (p, e) in zip(predicted_classes, exact_classes):
		if p == e:
			correct_cases += 1

	return correct_cases / len(predicted_classes)


def classify_custom_input(b_clf):
	input_features = []
	for i in range(0, 5):
		input_features.append(float(input()))

	print(b_clf.predict([input_features[:-1]])[0])


if __name__ == '__main__':
	warnings.filterwarnings('ignore', category=ConvergenceWarning)
	train, test = split_dataset(DATASET)
	train_x, train_y = divide_set(train)
	test_x, test_y = divide_set(test)

	learning_rates = [0.003, 0.05, 0.7]
	classifiers = []

	for rate in learning_rates:
		clf = MLPClassifier((3,), activation='relu', learning_rate_init=rate, max_iter=200, random_state=0)
		clf.fit(train_x, train_y)
		classifiers.append(clf)

	accuracies = {}

	for (i, rate) in enumerate(learning_rates):
		classifiers[i].predict(test_x)
		accuracies["{}".format(rate)] = (calculate_accuracy(classifiers[i].predict(test_x), test_y), i)

	best_acc_lr_index = max(list(accuracies.values()), key=lambda x: x[0])[1]
	best_clf = classifiers[best_acc_lr_index]
	best_acc = learning_rates[best_acc_lr_index]

	print("Best learning rate: {}".format(best_acc))
	classify_custom_input(best_clf)
